<?php

namespace App\Tests\Generator;

use App\Container\IoC;
use App\Move\MovableInterface;
use App\Move\MovingObject;
use App\Plugin\AdapterPlugin;
use App\Rotate\RotatableInterface;
use App\Tests\Stub\FinishAwareStubInterface;
use App\Tests\TestCase\BaseIoCUsingTestTrait;
use App\Vector\Vector;
use PHPUnit\Framework\TestCase;
use App\Generator\AdapterGenerator;
use stdClass;

class AdapterGeneratorTest extends TestCase
{
    use BaseIoCUsingTestTrait;

    protected function setUp(): void
    {
        $this->initIoC();

        (new AdapterPlugin())->load();
    }

    public function testCreateAdapter(): void
    {
        $mockObj = self::createMock(MovingObject::class);

        $adapter = IoC::resolve('Adapter', RotatableInterface::class, $mockObj);

        // Проверка типа возвращаемого объекта
        self::assertInstanceOf('App\\AutoGenerated\\RotatableInterfaceAdapter', $adapter);

        // Проверка методов адаптера, которые добавились из RotatableInterface
        self::assertTrue(method_exists($adapter, 'getDirection'));
        self::assertTrue(method_exists($adapter, 'getAngularVelocity'));
        self::assertTrue(method_exists($adapter, 'setDirection'));
    }

    public function testMovableAdapterAndFinishAwareAdapter(): void
    {
        $obj = new stdClass();

        $movableAdapter = IoC::resolve('Adapter', MovableInterface::class, $obj);

        // Проверка методов адаптера, которые добавились из MovableInterface
        self::assertTrue(method_exists($movableAdapter, 'getPosition'));
        self::assertTrue(method_exists($movableAdapter, 'getVelocity'));
        self::assertTrue(method_exists($movableAdapter, 'setPosition'));
        self::assertTrue(method_exists($movableAdapter, 'setVelocity'));

        IoC::resolve('ioc.register', 'stdClass:getPosition', function (stdClass $obj) {
            return $obj->_position;
        })->execute();

        IoC::resolve('ioc.register', 'stdClass:getVelocity', function (stdClass $obj) {
            return $obj->_velocity;
        })->execute();

        IoC::resolve('ioc.register', 'stdClass:setPosition', function (stdClass $obj, Vector $position) {
            $obj->_position = $position;
        })->execute();

        IoC::resolve('ioc.register', 'stdClass:setVelocity', function (stdClass $obj, Vector $velocity) {
            $obj->_velocity = $velocity;
        })->execute();

        $position = new Vector(10, 20);
        $velocity = new Vector(5, 15);

        $movableAdapter->setPosition($position);
        $movableAdapter->setVelocity($velocity);

        self::assertEquals($position, $movableAdapter->getPosition());
        self::assertEquals($velocity, $movableAdapter->getVelocity());


        // Ниже проверка п.3 "void finish()";

        $finishAwareAdapter = AdapterGenerator::createAdapter(FinishAwareStubInterface::class, $movableAdapter);

        // Проверка методов адаптера, которые добавились из FinishAwareStubInterface
        self::assertTrue(method_exists($finishAwareAdapter, 'finish'));

        IoC::resolve(
            'ioc.register',
            'App\AutoGenerated\MovableInterfaceAdapter:finish',
            function ($obj) {
                // Для проверки корректности вызова метода finish
                $obj->finished = true;
            },
        )->execute();

        $finishAwareAdapter->finish();

        // Проверка корректности вызова метода finish. True значит вызвался корректно
        self::assertTrue($movableAdapter->finished);
    }
}